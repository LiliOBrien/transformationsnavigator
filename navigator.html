import React, { useEffect, useMemo, useRef, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Info } from "lucide-react";
import {
  Radar,
  RadarChart,
  PolarGrid,
  PolarAngleAxis,
  PolarRadiusAxis,
  ResponsiveContainer,
  Tooltip,
  Legend,
} from "recharts";

const MODEL = {
  factors: [
    "Personalentwicklung & Lernbereitschaft",
    "Führungsverhalten",
    "Stakeholderbeziehungen",
    "Prozesse",
    "Informationsfluss & Kommunikation",
    "Technologie",
    "Vision & Werte",
    "Motivation & Arbeitsatmosphäre",
    "Innovationsfreude",
    "Fehler- & Konfliktkultur",
    "Produkte und Dienstleistungen",
    "Ressourceneffizienz & Nachhaltigkeit",
  ],
  influence: [
    [2,0,2,1,2,1,0,1,0,1,2,1], // Personalentwicklung
    [0,0,1,2,2,2,1,2,1,2,1,1], // Führungsverhalten (angepasst aus Führung)
    [0,0,0,1,1,0,1,0,2,1,0,2], // Stakeholderbeziehungen
    [2,0,0,0,1,2,0,1,1,2,1,0], // Prozesse
    [1,1,1,2,0,1,1,0,0,0,1,0], // Informationsfluss
    [0,1,0,2,1,0,0,0,2,1,0,0], // Technologie
    [2,1,1,0,1,1,0,0,1,1,1,0], // Vision & Werte
    [1,1,2,1,0,1,0,0,2,0,1,1], // Motivation
    [0,0,1,0,0,0,0,0,2,1,2,0], // Innovation
    [1,1,0,1,1,0,1,0,0,0,1,0], // Konflikt
    [0,0,0,1,1,0,2,1,0,2,0,1], // Produkte
    [0,0,0,1,0,0,0,1,1,0,1,0], // Ressourceneffizienz
  ],
} as const;

const clampInt = (v: number, lo = 1, hi = 10): number => {
  const n = Number.isFinite(v) ? Math.round(v) : lo;
  return Math.max(lo, Math.min(hi, n));
};

function propagate(
  base: number[],
  deltas: number[],
  influence: number[][],
  sensitivity: number
): number[] {
  const n = base.length;
  const acc = base.slice();

  for (let i = 0; i < n; i++) {
    const di = deltas[i] || 0;
    if (di === 0) continue;
    for (let j = 0; j < n; j++) {
      if (i === j) continue;
      acc[j] = acc[j] + di * (influence[i]?.[j] ?? 0) * sensitivity;
    }
  }
  for (let i = 0; i < n; i++) {
    if ((deltas[i] || 0) !== 0) acc[i] = base[i] + deltas[i];
  }
  return acc.map((v) => clampInt(v));
}

function PolarLabelTick(props: any) {
  const { x, y, payload, textAnchor } = props;
  const raw: string = payload?.value ?? "";
  const words = String(raw).split(" ");
  const lines: string[] = [];
  let current = "";
  const maxLen = 20;
  for (const w of words) {
    if ((current + " " + w).trim().length > maxLen) {
      if (current.length) lines.push(current);
      current = w;
    } else {
      current = (current ? current + " " : "") + w;
    }
  }
  if (current.length) lines.push(current);
  const lineHeight = 14;
  const total = lines.length;
  const startDy = -(lineHeight * (total - 1)) / 2;
  return (
    <g transform={`translate(${x},${y})`}>
      <text textAnchor={textAnchor} fontSize={13}>
        {lines.map((ln, idx) => (
          <tspan key={idx} x={0} dy={idx === 0 ? startDy : lineHeight}>
            {ln}
          </tspan>
        ))}
      </text>
    </g>
  );
}

/**
 * Overlay-Layer: Ziffern 1..10 auf JEDEM Strahl.
 * Wir messen die Containergröße und projizieren für jede Achse (Faktor) und jeden Level (1..10)
 * die Position mit Polar-Koordinaten (12 Uhr = 0, im Uhrzeigersinn).
 */
function AxisNumbersOverlay({ count }: { count: number }) {
  const ref = useRef<HTMLDivElement | null>(null);
  const [size, setSize] = useState<{ w: number; h: number }>({ w: 0, h: 0 });

  useEffect(() => {
    if (!ref.current) return;
    const ro = new ResizeObserver((entries) => {
      for (const e of entries) {
        const cr = e.contentRect;
        setSize({ w: cr.width, h: cr.height });
      }
    });
    ro.observe(ref.current);
    return () => ro.disconnect();
  }, []);

  // Render children as absolute SVG overlay
  const cx = size.w / 2;
  const cy = size.h / 2;
  // gleiche Skalierung wie RadarChart outerRadius="95%"
  const outerR = Math.min(size.w, size.h) * 0.95 * 0.5;

  const labels: React.ReactNode[] = [];
  for (let i = 0; i < count; i++) {
    // 12 Uhr = -90°, im Uhrzeigersinn weiter
    const angle = (-2 * Math.PI * i) / count - Math.PI / 2;
    for (let lvl = 1; lvl <= 10; lvl++) {
      const t = (lvl - 1) / 9; // 0..1
      const r = outerR * t;
      const x = cx + r * Math.cos(angle);
      const y = cy + r * Math.sin(angle);
      // kleines Offset entlang des Strahls, damit die 1 nicht direkt im Zentrum klebt
      const off = 8;
      const x2 = x + Math.cos(angle) * (lvl === 1 ? off : 0);
      const y2 = y + Math.sin(angle) * (lvl === 1 ? off : 0);
      labels.push(
        <text
          key={`axnum-${i}-${lvl}`}
          x={x2}
          y={y2}
          fontSize={10}
          textAnchor="middle"
          alignmentBaseline="middle"
          fill="#6b7280" // neutral-500
        >
          {lvl}
        </text>
      );
    }
  }

  return (
    <div ref={ref} className="pointer-events-none absolute inset-0">
      <svg width={size.w} height={size.h}>
        {labels}
      </svg>
    </div>
  );
}

export default function InteractiveFactorMap() {
  const factors = MODEL.factors as readonly string[];
  const influence = MODEL.influence as number[][];
  const n = factors.length;

  const [ist, setIst] = useState<number[]>(Array(n).fill(5));
  const [istBaseline, setIstBaseline] = useState<number[]>(Array(n).fill(5));
  const [targets, setTargets] = useState<number[]>(Array(n).fill(5));
  const [sensitivity, setSensitivity] = useState<number>(0.25);
  const [smartTip, setSmartTip] = useState<string>("");

  const [goals, setGoals] = useState<number[]>(Array(n).fill(0));
  const [driverLimit, setDriverLimit] = useState<number>(5);

  const handleIstChange = (i: number, v: number) => {
    const val = clampInt(v);
    setIst((prev) => prev.map((x, j) => (j === i ? val : x)));
    setTargets((prev) => prev.map((x, j) => (j === i ? val : x)));
    setIstBaseline((prev) => prev.map((x, j) => (j === i ? val : x)));
  };

  const soll = useMemo(() => {
    const deltas = targets.map((t, i) => clampInt(t) - istBaseline[i]);
    return propagate(istBaseline, deltas, influence, sensitivity);
  }, [istBaseline, targets, influence, sensitivity]);

  const radarData = useMemo(
    () =>
      factors.map((name, i) => ({ subject: name, IST: ist[i], SOLL: soll[i] })),
    [factors, ist, soll]
  );

  const setTargetValue = (i: number, v: number) =>
    setTargets((prev) => prev.map((x, j) => (j === i ? clampInt(v) : x)));

  const freezeIst = () => {
    setIstBaseline(ist.slice());
    setSmartTip("IST wurde eingefroren. Baseline aktualisiert.");
  };

  const resetSoll = () => {
    setTargets(istBaseline.slice());
    setSmartTip("SOLL zurückgesetzt (Ziele = Baseline). Wenn Baseline = IST, dann SOLL = IST.");
  };

  const smartTransformation = () => {
    const base = istBaseline;
    const m = influence;
    const N = n;

    let bestI = 0;
    let bestJ = 1;
    let bestScore = -Infinity;

    for (let i = 0; i < N; i++) {
      for (let j = i + 1; j < N; j++) {
        const trialTargets = base.slice();
        trialTargets[i] = clampInt(base[i] + 2);
        trialTargets[j] = clampInt(base[j] + 2);
        const deltas = trialTargets.map((t, idx) => t - base[idx]);
        const res = propagate(base, deltas, m, sensitivity);
        let score = 0;
        for (let k = 0; k < N; k++) {
          const diff = res[k] - base[k];
          if (diff > 0) score += diff;
        }
        if (score > bestScore) {
          bestScore = score;
          bestI = i;
          bestJ = j;
        }
      }
    }

    const nextTargets = base.slice();
    nextTargets[bestI] = clampInt(base[bestI] + 2);
    nextTargets[bestJ] = clampInt(base[bestJ] + 2);
    setTargets(nextTargets);
    setSmartTip(
      `Smart transformation: Verbesserung bei "${factors[bestI]}" und "${factors[bestJ]}" (+2 Punkte) bringt den größten Gesamteffekt (~+${bestScore}).`
    );
  };

  const sollClass = (i: number): string => {
    if (targets[i] !== ist[i]) return "text-green-600 font-semibold"; // manuell geändert
    if (soll[i] !== targets[i]) return "text-green-800 font-semibold"; // durch Propagation verändert
    return "text-neutral-800"; // unverändert
  };

  return (
    <div className="min-h-screen w-full bg-neutral-50 p-6 md:p-10">
      <div className="mx-auto max-w-7xl grid grid-cols-1 xl:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>1) Standortbestimmung und Ziel-Werte</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="grid grid-cols-12 text-xs text-muted-foreground">
              <div className="col-span-6 md:col-span-6">Faktor</div>
              <div className="col-span-2 text-right">IST</div>
              <div className="col-span-2 text-right">Ziel (manuell)</div>
              <div className="col-span-2 text-right">SOLL (berechnet)</div>
            </div>

            <div className="space-y-3">
              {factors.map((f, i) => (
                <div key={i} className="grid grid-cols-12 items-center gap-2">
                  <div className="col-span-6 md:col-span-6 text-sm md:text-base font-medium leading-tight whitespace-normal break-words" title={f}>
                    {i + 1}. {f}
                  </div>

                  <div className="col-span-2 flex justify-end">
                    <Input
                      type="number"
                      min={1}
                      max={10}
                      step={1}
                      className="w-20"
                      value={ist[i]}
                      onChange={(e) => {
                        const num = clampInt(parseInt(e.target.value || "0", 10));
                        handleIstChange(i, num);
                      }}
                    />
                  </div>

                  <div className="col-span-2 flex justify-end">
                    <Input
                      type="number"
                      min={1}
                      max={10}
                      step={1}
                      className={`w-20 ${targets[i] !== istBaseline[i] ? 'text-green-600 font-semibold' : ''}`}
                      value={targets[i]}
                      onChange={(e) => {
                        const num = clampInt(parseInt(e.target.value || "0", 10));
                        setTargetValue(i, num);
                      }}
                    />
                  </div>

                  <div className="col-span-2 flex justify-end items-center gap-2">
                    {(() => {
                      const base = istBaseline[i];
                      const isManual = targets[i] !== base;
                      const computed = soll[i];
                      const unchanged = computed === base;
                      const cls = unchanged
                        ? 'text-neutral-800'
                        : isManual
                        ? 'text-green-600 font-semibold'
                        : 'text-green-800 font-semibold';
                      const diff = computed === ist[i]
                        ? '+0'
                        : computed > ist[i]
                        ? `+${computed - ist[i]}`
                        : `-${ist[i] - computed}`;
                      return (
                        <>
                          <span className={`text-xs ${cls}`}>{diff}</span>
                          <span className={`w-12 text-right ${cls}`}>{computed}</span>
                        </>
                      );
                    })()}
                  </div>
                </div>
              ))}
            </div>

            <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
              <Button variant="outline" onClick={freezeIst}>IST einfrieren</Button>
              <Button variant="outline" onClick={resetSoll}>SOLL zurücksetzen</Button>
              <Button onClick={smartTransformation}>Smart transformation</Button>
            </div>

            {smartTip && <div className="text-xs text-muted-foreground">{smartTip}</div>}

            <div>
              <label className="text-xs text-muted-foreground">Sensitivität der Kopplungen</label>
              <div className="mt-2 flex items-center gap-3">
                <input
                  type="range"
                  min={0.05}
                  max={0.5}
                  step={0.05}
                  value={sensitivity}
                  onChange={(e) => setSensitivity(parseFloat(e.target.value))}
                />
                <div className="text-sm w-24 text-right">{sensitivity.toFixed(2)}</div>
              </div>
            </div>

            <div className="text-xs text-muted-foreground">
              SOLL wird relativ zur <strong>Baseline</strong> berechnet. Nutze „IST einfrieren“, um die Baseline auf den aktuellen IST-Stand zu setzen.
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <span>2) Spinnennetz</span>
              <Info className="h-4 w-4 text-muted-foreground" />
            </CardTitle>
          </CardHeader>
          <CardContent className="h-[900px]">
            <div className="relative w-full h-full">
              <ResponsiveContainer width="100%" height="100%">
                <RadarChart data={radarData} cx="50%" cy="50%" outerRadius="95%" startAngle={90} endAngle={-270}>
                  <PolarGrid />
                  <PolarAngleAxis dataKey="subject" tickMargin={24} tick={<PolarLabelTick />} />
                  <PolarRadiusAxis angle={30} domain={[1, 10]} tick={false} />
                  <Radar name="IST" dataKey="IST" stroke="#2563eb" fill="#2563eb" strokeWidth={2.5} fillOpacity={0.22} />
                  <Radar name="SOLL (Prognose)" dataKey="SOLL" stroke="#16a34a" fill="#16a34a" strokeDasharray="5 3" strokeWidth={2} fillOpacity={0.12} />
                  <Tooltip formatter={(v: number) => clampInt(v)} />
                  <Legend />
                </RadarChart>
              </ResponsiveContainer>
              {/* Overlay mit Ziffern 1..10 auf jedem Strahl */}
              <AxisNumbersOverlay count={n} />
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
